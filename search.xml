<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot秒杀商城]]></title>
    <url>%2F2019%2F07%2F02%2FSpringBoot%E7%A7%92%E6%9D%80%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[SpringBoot秒杀商城SpringBoot并非什么新的框架，SpringBoot就是Spring + Boot，如同Maven整合了所有的jar包一样，SpringBoot整合了所有框架，并通过main函数启动。 开发设计1.1 项目建立 maven-archetype-quickstart建立SpringBoot项目 - 引入parent依赖与starter依赖12345678910&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 加入注解使得SpringBoot开始运行 123456789@EnableAutoConfiguration # Spring化public class App &#123; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); SpringApplication.run(App.class, args); # 将App变成bean的形式 &#125;&#125; 增加rest式外部访问流程 123456789101112131415@EnableAutoConfiguration@RestController # rest访问控制public class App &#123; @RequestMapping("/") # rest映射 public String home()&#123; return "Hello, World!"; &#125; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); SpringApplication.run(App.class, args); &#125;&#125; 1.2 文件配置 加入application.propertites配置文件就可以配置端口等 配置数据库 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 在application.properties中加入mybatis.mapper-locations=classpath:mapping/*.xml支持 引入mybatis的自动生成插件 1234567891011121314151617181920212223242526272829303132333435363738&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;mybatis generator&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!--允许移动生成文件--&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!--允许自动覆盖--&gt; &lt;!--这个一般企业开发不能覆盖，否则别人的成果会受影响--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!--这个极其重要--&gt; &lt;configurationFile&gt; src/main/resources/mybatis-generator.xml &lt;/configurationFile&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; mybatis-generator的官方文档的地址官方文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--JDBC驱动jar包的位置--&gt; &lt;!--&lt;classPathEntry location="C:/workspace/project/learning/mybatis/lib/mysql-connector-java-5.1.6.jar"/&gt;--&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!--创建Java类时是否取消生成注释--&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--JDBC数据库连接--&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/test" userId="root" password="dev"&gt; &lt;/jdbcConnection&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage="dulk.learn.mybatis.generator.pojo" targetProject="src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- 是否对model添加构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage="generator" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件的代码 type="ANNOTATEDMAPPER",生成Java Model和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.xxx.dao" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!--tables表及类名--&gt; &lt;table tableName="author" domainObjectName="Author" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;/table&gt; &lt;table tableName="book" domainObjectName="Book" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 这是一种比较详细的配置方式。 2.1 表结构设计及自动生成 1）密码和表结构是分开设计的，为user_info与user_password，且密码要加密存入 2）设置好plugins和具体的配置文件之后，即可通过generator生成一个新的mybatis文件，注意tables等指标都要重新设计 3）之后在Run的配置栏中选中edit configuration配置，新建maven，然后配置mybatis-generator命令并执行 出现如下报错，是数据库版本问题。CSDN1Unknown system variable &apos;query_cache_size&apos; 注意把table中的几个字段设置为自动生成false后可以删除掉生成的Example 在application下配置 12345678spring.datasource.name=seckillmallspring.datasource.url=jdbc:mysql://xxxx:3306/seckillmallspring.datasource.data-username=&quot;xxx&quot;spring.datasource.data-password=&quot;xxx&quot;# 使用druid数据源spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driver 2.2 修改App主入口 加入spring新注解扫描，替换之前的 123456789101112131415161718@SpringBootApplication(scanBasePackages = &#123;"com.seckillmall"&#125;)@RestController@MapperScan("com.seckillmall.dao")public class App &#123; @Autowired private UserDOMapper userDOMapper; @RequestMapping("/") public String home()&#123; UserDO userDO = userDOMapper.selectByPrimaryKey(1); if(userDO == null)&#123; return "用户不存在"; &#125;else&#123; return userDO.getName(); &#125; &#125;&#125; 注：这里有一个BUG，Mybatis的自动生成覆写很智障!!每次都会在头部插入新的代码段，需要手动控制，不然会报resultMap错误。 *注2：这里还有一个问题，Druid的配置过程中参数一定要写对，有的时候是spring.datasource.username而不是spring.datasource.data-username 注3：报错Communications link failure的时候直接刷新一下重启就好了，可能是TCP连接的重建问题。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Serverless与Faas的探究]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%85%B3%E4%BA%8EServerless%E4%B8%8EFaas%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[关于Serverless与Faas这里的FAAS是指function as a service，主要实现有开源的OpenFaas（基于docker）与亚马逊的Lambda来实现。而Serverless现有的业界处理方案还是集中在下图类似的情景下：但注意，思维不要局限，这只是业界如何使用的例子，应当对如何进一步拓宽使用范围抱有信心。“将业务函数抽象成一个个 FAAS 函数，将数据库、缓存、加速等服务抽象成 BAAS 服务。上层提供 Restful 或事件触发机制调用，对应到不同的端（PC、移动端）。想要拓展平台能力，只要在端上做开放（组件接入）与 FAAS 服务做开放（后端接入）即可。” 对于现状的一种分析：这里挂一篇笔者的文章，参见笔记《理论 - 知乎：Serverless是进步还是退步》两篇论文的地址Serverless computing：One Step Forward，Two Steps BackCloud Programming Simplified：A Berkeley View on Serverless Computing 说的很清楚，现有的Serverless服务主要的一个优势和两个问题：Faas是“事件驱动”的，因此需要有更好的事件驱动支持优势：解耦，使得服务的部署更加简单以及松耦合. “提供了一种弹性的，自动扩缩容的编程模式，是一大进步。”劣势：1）传统服务为将代码传输到数据端工作，现有服务则是将数据传输到代码端工作，即“Data-shipping”模式，忽视了数据处理的效率2）阻碍了分布式计算的发展，“ Faas 的函数之间不是通过网络进行端到端通信的，那么以计算机网络为基础的分布式计算理论和通信协议，例如数据一致性，leader 选举，分布式事务等的发展会受到阻碍。” 联想的另一端是互联网之父的solid项目，有其他的参考意义在其中同时，RDF（Resource Description Framework）的理解，也有提及：即语义网]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>技术理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP粘包问题成因及其解决办法]]></title>
    <url>%2F2019%2F04%2F13%2FTCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%88%90%E5%9B%A0%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[研究TCP粘包问题近期和同学讨论了一个关于TCP粘包的问题，他在分布式机器学习的数据传输中发现TCP通信出现问题。因此也研究了一下自己之前项目中使用的代码 —— 是通过规定头部字段记录代码长度的方式来实现的。这里总结一下查到的资料。引用博客 问题的成因 socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说，就容易进行区分处理了,所以UDP不会出现粘包问题。 实际上TCP是面向流的传输协议，而UDP是面向消息的传输协议，如何保护消息边界的问题是解决粘包问题的关键。 产生粘包的两种情况 1发送端需要等缓冲区满才发送出去，造成粘包 2接收方不及时接收缓冲区的包，造成多个包接收 具体点：（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结构数据的粘包问题时，分包算法就比较复杂。特别是粘在一起的包有不完整的包的粘包情况，由于一包数据内容被分在了两个连续的接收包中，处理起来难度较大。实际工程应用中应尽量避免出现粘包现象。 解决方案 (1)发送固定长度的消息 (2)把消息的尺寸与消息一块发送 (3)使用特殊标记来区分消息间隔 之前的代码之前的一种限定长度的代码为： 发送：1234567@classmethod def encode_socket_data(cls, data: object) -&gt; bytes: """Our protocol is: first 4 bytes signify msg length.""" def int_to_8bytes(a: int) -&gt; bytes: return binascii.unhexlify(f"&#123;a:0&#123;8&#125;x&#125;") to_send = Utils.serialize(data).encode() return int_to_8bytes(len(to_send)) + to_send 接收：123456789101112try: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect(peer()) s.sendall(Utils.encode_socket_data(message)) logger.info(f'[p2p] succeed to send BlocksSyncReq to &#123;peer&#125;') msg_len = int(binascii.hexlify(s.recv(4) or b'\x00'), 16) data = b'' while msg_len &gt; 0: tdat = s.recv(1024) data += tdat msg_len -= len(tdat) s.close() 规定开头四字节的长度即可在缓冲区中区分TCP数据包。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>技术理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2P网络中内网穿透的方法]]></title>
    <url>%2F2019%2F01%2F22%2FP2P%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[P2P网络中内网穿透的方法今天学长让我查一下这个，研究了一下，各种资料五花八门，自己总结了一下备查。是关于一个局域网和外网之间连接的问题:首先问题的关键在于： 由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。 方案一理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。Python写的比较常用的实现TCP内网穿透的服务器是ShootBack： 方案二另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；但这种方法存在的问题：——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；——这种方法受到不同网络状况和设备的影响很大；——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况； 方案三STUN协议和TURN协议STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。网上开源项目也很多：显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualEnv常用命令]]></title>
    <url>%2F2019%2F01%2F14%2FVirtualEnv%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近python用的多Pycharm的基本配置和记录中Virtualenv的使用都记录在这里。基本配置再有这是virtualenv的所有基础操作基础操作 自己Mac的virtualenv环境在：~/.virtualenv文件夹下面。一些常见的virtual命令：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>技术链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志模板]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[XXXX # 一级标题斜体文字加粗文字粗斜体文字 文本居中的引用测试测试2 hello worldfor(int i=0;i&lt;len;i++){ step++;} 文字内容 (md class_name supported) 文字内容 (md primary supported) 文字内容 (md default supported) 文字内容 (md success supported) 文字内容 (md info supported) 文字内容 (md warning supported) 文字内容 (md danger supported) 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[众包项目]]></title>
    <url>%2F2019%2F01%2F13%2F%E4%BC%97%E5%8C%85%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[边缘群智项目记录2019.1.13打卡，明天下午一点开会，开始搞这个，记录一下流程。众包相关知识快速代码上手 项目入门项目介绍图，是一些学长的资料 第一个研究问题是关于一个局域网和外网之间连接的问题:首先问题的关键在于： 由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。 方案一理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。Python写的比较常用的实现TCP内网穿透的服务器是ShootBack： 方案二另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；但这种方法存在的问题：——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；——这种方法受到不同网络状况和设备的影响很大；——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况； 方案三STUN协议和TURN协议STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。网上开源项目也很多：显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。]]></content>
      <categories>
        <category>区块链</category>
        <category>众包</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习和大数据资料整理]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[机器学习相关技术链接贴一些常用的链接就不到Chorme tabs里找了。 机器学习 我的google云盘吴恩达b站视频林轩石机器学习莫烦的TF教程西瓜书答案贝叶斯讲解PRML书目 大数据 CS231n: Convolutional Neural Networks for Visual RecognitionScalable Machine LearningIntroduction to Apache Spark]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>技术链接</tag>
      </tags>
  </entry>
</search>
