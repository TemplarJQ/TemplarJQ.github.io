<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Serverless与Faas的探究]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%85%B3%E4%BA%8EServerless%E4%B8%8EFaas%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[关于Serverless与Faas这里的FAAS是指function as a service，主要实现有开源的OpenFaas（基于docker）与亚马逊的Lambda来实现。而Serverless现有的业界处理方案还是集中在下图类似的情景下：但注意，思维不要局限，这只是业界如何使用的例子，应当对如何进一步拓宽使用范围抱有信心。“将业务函数抽象成一个个 FAAS 函数，将数据库、缓存、加速等服务抽象成 BAAS 服务。上层提供 Restful 或事件触发机制调用，对应到不同的端（PC、移动端）。想要拓展平台能力，只要在端上做开放（组件接入）与 FAAS 服务做开放（后端接入）即可。” 对于现状的一种分析：这里挂一篇笔者的文章，参见笔记《理论 - 知乎：Serverless是进步还是退步》两篇论文的地址Serverless computing：One Step Forward，Two Steps BackCloud Programming Simplified：A Berkeley View on Serverless Computing 说的很清楚，现有的Serverless服务主要的一个优势和两个问题：Faas是“事件驱动”的，因此需要有更好的事件驱动支持优势：解耦，使得服务的部署更加简单以及松耦合. “提供了一种弹性的，自动扩缩容的编程模式，是一大进步。”劣势：1）传统服务为将代码传输到数据端工作，现有服务则是将数据传输到代码端工作，即“Data-shipping”模式，忽视了数据处理的效率2）阻碍了分布式计算的发展，“ Faas 的函数之间不是通过网络进行端到端通信的，那么以计算机网络为基础的分布式计算理论和通信协议，例如数据一致性，leader 选举，分布式事务等的发展会受到阻碍。” 联想的另一端是互联网之父的solid项目，有其他的参考意义在其中同时，RDF（Resource Description Framework）的理解，也有提及：即语义网]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>技术理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP粘包问题成因及其解决办法]]></title>
    <url>%2F2019%2F04%2F13%2FTCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%88%90%E5%9B%A0%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[研究TCP粘包问题近期和同学讨论了一个关于TCP粘包的问题，他在分布式机器学习的数据传输中发现TCP通信出现问题。因此也研究了一下自己之前项目中使用的代码 —— 是通过规定头部字段记录代码长度的方式来实现的。这里总结一下查到的资料。引用博客 ##问题的成因 socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说，就容易进行区分处理了,所以UDP不会出现粘包问题。 实际上TCP是面向流的传输协议，而UDP是面向消息的传输协议，如何保护消息边界的问题是解决粘包问题的关键。 产生粘包的两种情况 1发送端需要等缓冲区满才发送出去，造成粘包 2接收方不及时接收缓冲区的包，造成多个包接收 具体点：（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结构数据的粘包问题时，分包算法就比较复杂。特别是粘在一起的包有不完整的包的粘包情况，由于一包数据内容被分在了两个连续的接收包中，处理起来难度较大。实际工程应用中应尽量避免出现粘包现象。 解决方案 (1)发送固定长度的消息 (2)把消息的尺寸与消息一块发送 (3)使用特殊标记来区分消息间隔 之前的代码之前的一种限定长度的代码为： 发送：@classmethod def encode_socket_data(cls, data: object) -&gt; bytes: &quot;&quot;&quot;Our protocol is: first 4 bytes signify msg length.&quot;&quot;&quot; def int_to_8bytes(a: int) -&gt; bytes: return binascii.unhexlify(f&quot;{a:0{8}x}&quot;) to_send = Utils.serialize(data).encode() return int_to_8bytes(len(to_send)) + to_send 接收：123456789101112try: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect(peer()) s.sendall(Utils.encode_socket_data(message)) logger.info(f&apos;[p2p] succeed to send BlocksSyncReq to &#123;peer&#125;&apos;) msg_len = int(binascii.hexlify(s.recv(4) or b&apos;\x00&apos;), 16) data = b&apos;&apos; while msg_len &gt; 0: tdat = s.recv(1024) data += tdat msg_len -= len(tdat) s.close() 规定开头四字节的长度即可在缓冲区中区分TCP数据包。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>技术理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2P网络中内网穿透的方法]]></title>
    <url>%2F2019%2F01%2F22%2FP2P%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[P2P网络中内网穿透的方法今天学长让我查一下这个，研究了一下，各种资料五花八门，自己总结了一下备查。是关于一个局域网和外网之间连接的问题:首先问题的关键在于： 由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。 方案一理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。Python写的比较常用的实现TCP内网穿透的服务器是ShootBack： 方案二另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；但这种方法存在的问题：——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；——这种方法受到不同网络状况和设备的影响很大；——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况； 方案三STUN协议和TURN协议STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。网上开源项目也很多：显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualEnv常用命令]]></title>
    <url>%2F2019%2F01%2F14%2FVirtualEnv%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近python用的多Pycharm的基本配置和记录中Virtualenv的使用都记录在这里。基本配置再有这是virtualenv的所有基础操作基础操作 自己Mac的virtualenv环境在：~/.virtualenv文件夹下面。一些常见的virtual命令：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>技术链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志模板]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[XXXX # 一级标题斜体文字加粗文字粗斜体文字 文本居中的引用测试测试2 hello worldfor(int i=0;i&lt;len;i++){ step++;} 文字内容 (md class_name supported) 文字内容 (md primary supported) 文字内容 (md default supported) 文字内容 (md success supported) 文字内容 (md info supported) 文字内容 (md warning supported) 文字内容 (md danger supported) 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[众包项目]]></title>
    <url>%2F2019%2F01%2F13%2F%E4%BC%97%E5%8C%85%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[边缘群智项目记录2019.1.13打卡，明天下午一点开会，开始搞这个，记录一下流程。众包相关知识快速代码上手 项目入门项目介绍图，是一些学长的资料 第一个研究问题是关于一个局域网和外网之间连接的问题:首先问题的关键在于： 由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。 方案一理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。Python写的比较常用的实现TCP内网穿透的服务器是ShootBack： 方案二另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；但这种方法存在的问题：——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；——这种方法受到不同网络状况和设备的影响很大；——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况； 方案三STUN协议和TURN协议STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。网上开源项目也很多：显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。]]></content>
      <categories>
        <category>区块链</category>
        <category>众包</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习和大数据资料整理]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[机器学习相关技术链接贴一些常用的链接就不到Chorme tabs里找了。 机器学习 我的google云盘吴恩达b站视频林轩石机器学习莫烦的TF教程西瓜书答案贝叶斯讲解PRML书目 大数据 CS231n: Convolutional Neural Networks for Visual RecognitionScalable Machine LearningIntroduction to Apache Spark]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>技术链接</tag>
      </tags>
  </entry>
</search>
