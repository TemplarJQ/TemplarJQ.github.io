<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot秒杀商城]]></title>
    <url>%2F2019%2F07%2F02%2FSpringBoot%E7%A7%92%E6%9D%80%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[SpringBoot秒杀商城SpringBoot并非什么新的框架，SpringBoot就是Spring + Boot，如同Maven整合了所有的jar包一样，SpringBoot整合了所有框架，并通过main函数启动。 开发设计1.1 项目建立 maven-archetype-quickstart建立SpringBoot项目 - 引入parent依赖与starter依赖12345678910&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 加入注解使得SpringBoot开始运行 123456789@EnableAutoConfiguration # Spring化public class App &#123; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); SpringApplication.run(App.class, args); # 将App变成bean的形式 &#125;&#125; 增加rest式外部访问流程 123456789101112131415@EnableAutoConfiguration@RestController # rest访问控制public class App &#123; @RequestMapping("/") # rest映射 public String home()&#123; return "Hello, World!"; &#125; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); SpringApplication.run(App.class, args); &#125;&#125; 1.2 文件配置 加入application.propertites配置文件就可以配置端口等 配置数据库 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 在application.properties中加入mybatis.mapper-locations=classpath:mapping/*.xml支持 引入mybatis的自动生成插件 1234567891011121314151617181920212223242526272829303132333435363738&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;mybatis generator&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!--允许移动生成文件--&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!--允许自动覆盖--&gt; &lt;!--这个一般企业开发不能覆盖，否则别人的成果会受影响--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!--这个极其重要--&gt; &lt;configurationFile&gt; src/main/resources/mybatis-generator.xml &lt;/configurationFile&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; mybatis-generator的官方文档的地址官方文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--JDBC驱动jar包的位置--&gt; &lt;!--&lt;classPathEntry location="C:/workspace/project/learning/mybatis/lib/mysql-connector-java-5.1.6.jar"/&gt;--&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!--创建Java类时是否取消生成注释--&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--JDBC数据库连接--&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/test" userId="root" password="dev"&gt; &lt;/jdbcConnection&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage="dulk.learn.mybatis.generator.pojo" targetProject="src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- 是否对model添加构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage="generator" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件的代码 type="ANNOTATEDMAPPER",生成Java Model和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.xxx.dao" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!--tables表及类名--&gt; &lt;table tableName="author" domainObjectName="Author" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;/table&gt; &lt;table tableName="book" domainObjectName="Book" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 这是一种比较详细的配置方式。 2.1 表结构设计及自动生成 1）密码和表结构是分开设计的，为user_info与user_password，且密码要加密存入 2）设置好plugins和具体的配置文件之后，即可通过generator生成一个新的mybatis文件，注意tables等指标都要重新设计 3）之后在Run的配置栏中选中edit configuration配置，新建maven，然后配置mybatis-generator命令并执行 出现如下报错，是数据库版本问题。CSDN1Unknown system variable &apos;query_cache_size&apos; 注意把table中的几个字段设置为自动生成false后可以删除掉生成的Example 在application下配置 12345678spring.datasource.name=seckillmallspring.datasource.url=jdbc:mysql://xxxx:3306/seckillmallspring.datasource.data-username=&quot;xxx&quot;spring.datasource.data-password=&quot;xxx&quot;# 使用druid数据源spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driver 2.2 修改App主入口 加入spring新注解扫描，替换之前的 123456789101112131415161718@SpringBootApplication(scanBasePackages = &#123;"com.seckillmall"&#125;)@RestController@MapperScan("com.seckillmall.dao")public class App &#123; @Autowired private UserDOMapper userDOMapper; @RequestMapping("/") public String home()&#123; UserDO userDO = userDOMapper.selectByPrimaryKey(1); if(userDO == null)&#123; return "用户不存在"; &#125;else&#123; return userDO.getName(); &#125; &#125;&#125; 注：这里有一个BUG，Mybatis的自动生成覆写很智障!!每次都会在头部插入新的代码段，需要手动控制，不然会报resultMap错误。 *注2：这里还有一个问题，Druid的配置过程中参数一定要写对，有的时候是spring.datasource.username而不是spring.datasource.data-username 注3：报错Communications link failure的时候直接刷新一下重启就好了，可能是TCP连接的重建问题。 3.1 开发用户信息业务逻辑 1）先构建出UserController和UserService这些MVC常见组件，用于实现查询业务逻辑； controller 1234567891011121314@Controller("user")@RequestMapping("/user")public class UserController &#123; @Autowired private UserServiceImpl userService; @RequestMapping("/get") public void getUser(@RequestParam(name="id")Integer id)&#123; //调用service服务并获取对象 UserModel userModel = userService.getUserById(id); &#125;&#125; 2）这里引入一个重要概念是UserModel用于实现对前端的交互，组装了info和passward信息，因为Dao层的东西是不能透传给前端的；注意还要构建Model的从Dao转化到Model的方法 UserModel 12345678910111213141516171819202122232425262728@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDOMapper userDOMapper; //缺乏password的查询返回方法 @Override public UserModel getUserById(Integer id) &#123; UserDO userDO = userDOMapper.selectByPrimaryKey(id); //缺乏返回 return null; &#125; private UserModel convertFromDataObject(UserDO userDO, UserPassword userPassword)&#123; UserModel userModel = new UserModel(); if(userDO == null)&#123; return null; &#125; BeanUtils.copyProperties(userDO,userModel); if(userPassword != null)&#123; userModel.setEncrptPassword(userPassword.getEncrptPassword()); &#125; &#125;&#125; 3）引入自动化的然后改造Mybatis文件，进行下一步的处理后在service中进行修改 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDOMapper userDOMapper; @Autowired private UserPasswordMapper userPasswordMapper; @Override public UserModel getUserById(Integer id) &#123; //查询对应的业务逻辑 UserDO userDO = userDOMapper.selectByPrimaryKey(id); //用户不存在 if(userDO == null)&#123; return null; &#125; //查询密码等加密信息 UserPassword userPassword = userPasswordMapper.selectByUserId(id); return convertFromDataObject(userDO, userPassword); &#125; private UserModel convertFromDataObject(UserDO userDO, UserPassword userPassword)&#123; UserModel userModel = new UserModel(); if(userDO == null)&#123; return null; &#125; BeanUtils.copyProperties(userDO,userModel); if(userPassword != null)&#123; userModel.setEncrptPassword(userPassword.getEncrptPassword()); &#125; return userModel; &#125;&#125; 改进之后的service 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDOMapper userDOMapper; @Autowired private UserPasswordMapper userPasswordMapper; @Override public UserModel getUserById(Integer id) &#123; //查询对应的业务逻辑 UserDO userDO = userDOMapper.selectByPrimaryKey(id); //用户不存在 if(userDO == null)&#123; return null; &#125; //查询密码等加密信息 UserPassword userPassword = userPasswordMapper.selectByUserId(id); return convertFromDataObject(userDO, userPassword); &#125; private UserModel convertFromDataObject(UserDO userDO, UserPassword userPassword)&#123; UserModel userModel = new UserModel(); if(userDO == null)&#123; return null; &#125; BeanUtils.copyProperties(userDO,userModel); if(userPassword != null)&#123; userModel.setEncrptPassword(userPassword.getEncrptPassword()); &#125; return userModel; &#125;&#125; controller的配置 12345678910111213141516@Controller("user")@RequestMapping("/user")public class UserController &#123; @Autowired private UserServiceImpl userService; @RequestMapping("/get") @ResponseBody public UserModel getUser(@RequestParam(name="id")Integer id)&#123; //调用service服务并获取对象 UserModel userModel = userService.getUserById(id); return userModel; &#125;&#125; 注：没有写@ResponsBody后就会发现请求会无法显示成为json格式 3.2 重构改进 这样直接返回Json格式下用户密码，即便是加密格式下的，也会不是很好的设计方式，因此对它进行改造。 加入UserVO即ViewObject即可观察到最终的情况。 123456789101112public class UserVO &#123; private Integer id; private String name; private Byte gender; private Integer age; private String telphone;&#125; 现在的模式不允许任何错误，需要对它进行下一步的调整，需要归一化，建立response.CommonReturnType模式，将业务逻辑错误与服务器错误区分开来 1234567public class CommonReturnType &#123; //处理结果有"success"和"fail" private String status; private Object data;&#125; 3.3 错误异常处理 定义枚举类对错误信息进行处理 123456789101112131415161718192021222324252627282930313233public enum EmBusinessError implements CommonError &#123; //通用错误类型00001，解决入参校验 PARAMETER_VALIDATION_ERROR(00001, "参数不合法"), //10000开头表示为用户信息相关定义错误 User_NOT_EXIST(10001, "用户不存在") ; EmBusinessError(int errCode, String errMsg) &#123; this.errCode = errCode; this.errMsg = errMsg; &#125; private int errCode; private String errMsg; @Override public int getErrCode() &#123; return this.errCode; &#125; @Override public String getErrMsg() &#123; return this.errMsg; &#125; @Override public CommonError setErrMsg(String errMsg) &#123; this.errMsg = errMsg; return this; &#125;&#125; 处理流程为将所有异常抛到controller上的handler上进行处理，使用包装器模式构建Exception 12345678910111213141516171819202122232425262728293031323334//包装器业务异常类实现public class BusinessException extends Exception implements CommonError &#123; //强关联一个Error private CommonError commonError; //直接接受EmBusinessError的传参用于构造业务异常 public BusinessException(CommonError commonError) &#123; super(); this.commonError = commonError; &#125; //接受自定义ErrorMsg的方式接受业务异常 public BusinessException(CommonError commonError, String errMsg) &#123; super(); this.commonError = commonError; this.setErrMsg(errMsg); &#125; @Override public int getErrCode() &#123; return this.commonError.getErrCode(); &#125; @Override public String getErrMsg() &#123; return this.commonError.getErrMsg(); &#125; @Override public CommonError setErrMsg(String errMsg) &#123; return this.commonError.setErrMsg(errMsg); &#125;&#125; 然后在controller中对异常进行处理 1234567891011121314@RequestMapping("/get")@ResponseBodypublic CommonReturnType getUser(@RequestParam(name="id")Integer id) throws BusinessException &#123; //调用service服务并获取对象 UserModel userModel = userService.getUserById(id); if(userModel == null)&#123; throw new BusinessException(EmBusinessError.User_NOT_EXIST); &#125; //将核心领域模型用户转UI给用户使用的模型 UserVO userVO = convertFromModel(userModel); return CommonReturnType.create(userVO);&#125; 怎么拦截这个tomcat的异常处理过程显示呢？定义ExceptionHandler来解决未被controller层吸收的exception，采用@ResponseBody模式产生json。优化后的代码如下： 12345678910111213//定义ExceptionHandler解决未被controller层吸收的exception @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.OK)//屏蔽tomcat自己的处理 @ResponseBody public Object handlerException(HttpServletRequest request, Exception ex) &#123; BusinessException exception = (BusinessException) ex; Map&lt;String, Object&gt; responseData = new HashMap&lt;&gt;(); responseData.put("errCode", exception.getErrCode()); responseData.put("errMsg", exception.getErrMsg()); return CommonReturnType.create(responseData, "fail"); &#125; 添加BaseController后我们仍旧可以让UserController去继承该类。 12345678910111213141516171819public class BaseController &#123; //定义ExceptionHandler解决未被controller层吸收的exception @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.OK)//屏蔽tomcat自己的处理 @ResponseBody public Object handlerException(HttpServletRequest request, Exception ex) &#123; Map&lt;String, Object&gt; responseData = new HashMap&lt;&gt;(); if(ex instanceof BusinessException) &#123; BusinessException exception = (BusinessException) ex; responseData.put("errCode", exception.getErrCode()); responseData.put("errMsg", exception.getErrMsg()); &#125;else &#123; responseData.put("errCode", EmBusinessError.UNKNOWN_ERROR.getErrCode()); responseData.put("errMSg", EmBusinessError.UNKNOWN_ERROR.getErrMsg()); &#125; return CommonReturnType.create(responseData, "fail"); &#125;&#125; otp用户注册模块1.1 用户获取otp短信 首先的一个设计是生成otp代码，这个一般是通过购买第三方的服务实现的，而我们这里采用随机数生成的方式进行。 1234//获取otp随机码 Random random = new Random(); int randomCode = random.nextInt(99999); String optCode = String.valueOf(randomCode + 10000); 然后的一个设计为将otp与用户代码进行绑定，这一步一般是使用redis进行操作，这里采用简单的绑定到httpsession中进行处理。 12//与Httpsession进行绑定 httpServletRequest.setAttribute(telphone, optCode); 最后是输出otpcode，这里使用控制台输出检验 1234567891011121314151617@RequestMapping("/getotp") @ResponseBody public CommonReturnType getOtp(@RequestParam(name="telphone")String telphone)&#123; //获取otp随机码 Random random = new Random(); int randomCode = random.nextInt(99999); String optCode = String.valueOf(randomCode + 10000); //与Httpsession进行绑定 httpServletRequest.getSession().setAttribute(telphone, optCode); //将optcode返回给用户 System.out.println("telphone = "+ telphone + " &amp; optdoe = "+ optCode); return CommonReturnType.create(null); &#125; 1.2 用户注册逻辑实现 先校验optcode 12345678910111213public CommonReturnType register(@RequestParam(name="telphone")String telphone, @RequestParam(name = "id")Integer id, @RequestParam(name = "name")String name, @RequestParam(name = "gender")Byte gender, @RequestParam(name = "age")Integer age, @RequestParam(name = "optcode")String optCode ) throws BusinessException &#123; //首先校验optcode String inSessionCode = (String)this.httpServletRequest.getSession().getAttribute("telphone"); if(!com.alibaba.druid.util.StringUtils.equals(inSessionCode, optCode))&#123; throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, "注册短信验证错误"); &#125; &#125; 增加两个对应的转化字段 12345678910111213141516171819202122232425262728293031323334353637383940@Override public void register(UserModel userModel) throws BusinessException &#123; if(userModel == null)&#123; throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, "用户信息为空"); &#125; if(org.apache.commons.lang3.StringUtils.isEmpty(userModel.getName()) || userModel.getGender() == null || userModel.getAge() == null || org.apache.commons.lang3.StringUtils.isEmpty(userModel.getTelphone()))&#123; throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR); &#125; //实现model转化为dataobject UserDO userDO = convertFromUserModel(userModel); userDOMapper.insertSelective(userDO); UserPassword userPassword = convertPasswordFromUserModel(userModel); userPasswordMapper.insertSelective(userPassword); &#125; private UserPassword convertPasswordFromUserModel(UserModel userModel)&#123; if(userModel == null)&#123; return null; &#125; UserPassword userPassword = new UserPassword(); userPassword.setEncrptPassword(userModel.getEncrptPassword()); userPassword.setId(userModel.getId()); return userPassword; &#125; private UserDO convertFromUserModel(UserModel userModel)&#123; UserDO userDO = new UserDO(); if(userModel == null)&#123; return null; &#125; BeanUtils.copyProperties(userModel, userDO); return userDO; &#125; 前后端连接，注意先在其中加上@RequestMethod字段和一个content_type类型 123public static final String CONTENT_TYPE_FORMED = "application/x-www-form-urlencoded";···@RequestMapping(value = "/getotp", method = &#123;RequestMethod.POST&#125;, consumes = &#123;CONTENT_TYPE_FORMED&#125;) 然后处理ajax的跨域请求的问题为在controller上加入@CrossOrigin即可 对应的 xhrFields:{withCredentials:true}前端设置也是为了配合使用而设置的 注意BASE64的用法在JDK9之后发生了变化12345678public String enCodeByMD5(String str) throws NoSuchAlgorithmException, UnsupportedEncodingException &#123; // 确定计算方法 MessageDigest md5 = MessageDigest.getInstance("MD5"); BASE64Encoder base64Encoder = new BASE64Encoder(); // 加密字符串 String newStr = base64Encoder.encode(md5.digest(str.getBytes("utf-8"))); return newStr; &#125; 解决地址：jdk9之后 解决数据库唯一索引问题，添加对手机号的索引之后，就可以添加对于异常的处理过程，在register里catch到 1.3 验证模块的改进 增加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.4.Final&lt;/version&gt; &lt;/dependency&gt; 增加验证过程，使用hibernate自带的用户模块，新建ValidatorImpl，注意加注释能够使它在初始化过程中被扫描到 123456789101112131415161718192021222324252627@Componentpublic class ValidatorImpl implements InitializingBean &#123; private Validator validator; //实现校验方法 public ValidationResult validate(Object bean)&#123; ValidationResult validationResult = new ValidationResult(); Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolations = validator.validate(bean); if(constraintViolations.size() &gt; 0)&#123; //有错误 validationResult.setHasError(true); constraintViolations.forEach(constraintViolation -&gt; &#123; String errMsg = constraintViolation.getMessage(); String propertyName = constraintViolation.getPropertyPath().toString(); validationResult.getErrMsgMap().put(propertyName, errMsg); &#125;); &#125; return validationResult; &#125; @Override public void afterPropertiesSet() throws Exception &#123; //将hibernate validator的工厂模式使其实例化 this.validator = Validation.buildDefaultValidatorFactory().getValidator(); &#125;&#125; 然后配合注解的@NotBlank等就可以实现对于其的校验，这是一种hibernate+注解的方式 2.2 登录模块的修改 业务逻辑注意有对于Mapper.xml的修改 商品模块的实现 对于一个初级Java程序员来说，设计一个程序可能就是按照用户经理的UI设计去复现表结构，然后使用Mybatis对结构进行调整，但是这样设计是错误的。一定要先设计领域模型，也就是Model 1.1 商品模块的设计与实现 首先修改pom中mybatis自动生成的覆写参数！！ 然后在mybatis-generator上修改使其生成新的表参数 列出一个面向领域编程的典型设计service流程，service注解加上，然后Transactional主要保证对一个事务的读写 12345678910111213141516@Servicepublic class ItemServiceImpl implements ItemService &#123; @Override @Transactional public ItemModel createItem(ItemModel itemModel) &#123; //校验入参 //转化ItemModel变为DataObject //写入数据库 //返回创建对象 return null; &#125;&#125; Service层尽量写得复杂，Controller层则是尽量写得简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081Servicepublic class ItemServiceImpl implements ItemService &#123; @Autowired private ValidatorImpl validator; @Autowired private ItemDOMapper itemDOMapper; @Autowired private ItemStockDOMapper itemStockDOMapper; private ItemDO convertFromItemModel(ItemModel itemModel)&#123; if(itemModel == null)&#123; return null; &#125; ItemDO itemDO = new ItemDO(); BeanUtils.copyProperties(itemModel, itemDO); itemDO.setPrice(itemModel.getPrice().doubleValue()); return itemDO; &#125; private ItemStockDO convertStockFromItemModel(ItemModel itemModel)&#123; if(itemModel == null)&#123; return null; &#125; ItemStockDO itemStockDO = new ItemStockDO(); itemStockDO.setId(itemModel.getId()); itemStockDO.setStock(itemModel.getStock()); return itemStockDO; &#125; @Override @Transactional public ItemModel createItem(ItemModel itemModel) throws BusinessException &#123; //校验入参 ValidationResult validationResult = validator.validate(itemModel); if(validationResult.isHasErrors())&#123; throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, validationResult.getErrMsg()); &#125; //转化ItemModel变为DataObject ItemDO itemDO = this.convertFromItemModel(itemModel); //写入数据库 itemDOMapper.insertSelective(itemDO); itemModel.setId(itemDO.getId()); ItemStockDO itemStockDO = this.convertStockFromItemModel(itemModel); itemStockDOMapper.insertSelective(itemStockDO); //返回创建对象 return this.getItemById(itemModel.getId()); &#125; @Override public List&lt;ItemModel&gt; listItem() &#123; return null; &#125; @Override public ItemModel getItemById(Integer id) &#123; ItemDO itemDO = itemDOMapper.selectByPrimaryKey(id); if(itemDO == null) &#123; return null; &#125; //操作获得库存数量 ItemStockDO itemStockDO = itemStockDOMapper.selectByItemId( itemDO.getId()); //将dataobject转换成model return this.convertModelFromDataObject(itemDO,itemStockDO); &#125; private ItemModel convertModelFromDataObject(ItemDO itemDO,ItemStockDO itemStockDO)&#123; ItemModel itemModel = new ItemModel(); BeanUtils.copyProperties(itemDO,itemModel); itemModel.setPrice(new BigDecimal(itemDO.getPrice())); itemModel.setStock(itemStockDO.getStock()); return itemModel; &#125; 顺序是ItemModel -&gt; 生成表结构 -&gt; 写ItemService -&gt; 实现 -&gt; 写Controller层 -&gt; 写ItemVO用于返回给前端 1.3 前端展示商品 注意图片的引用格式 订单生成1.1 订单号生成 首先对订单进行Model设计 123456789101112131415161718192021//解决用户下单的交易模型public class OrderModel &#123; //企业级别应用的交易号是要记录时间的明显格式，如20190701+88888 private String id; //购买的用户id private Integer userId; //商品id private Integer itemId; //购买商品的单价，这家伙是到时候写秒杀用的东西，变化的时候要用 private BigDecimal itemPrice; //数目 private Integer amount; //总金额 private BigDecimal orderAmount;&#125; 使用Mybatis-generator生成相应的Mapper和DO模型； 创建OrderService，构建create方法，传入的参数为用户和订单的id，以及相应的数量； 构建Service实现以及加上@service标注，重写方法，并保证事务是在同一个订单当中，@Transactional； 1）校验用户及商品存在-&gt;2）校验商品-&gt;3）落单并减库存/支付减库存（更难，且无法避免超卖问题，要造成退单）-&gt; 4）订单入库 -&gt; 5）返回前端 这里有两个可以展开来研究的点： 第一个就是一个落单减库存，虽然是合情合理的，但是可能被恶意下单，从而造成损失；商家为了让用户及早进行交易的提交，采用支付减库存的方式，但是这样又会遇到超卖退单的问题，用户体验较差，因此需要进行进一步的处理，超卖问题的解决是依靠——备货来解决的，但是要有限度。 第二个就是在落单减库存的时候，我们要对stock进行操作，其实这里完全可以独立出一个Service操作对stock进行进一步的优化，可以展开来写。 详细步骤 1）校验有三个信息并抛出异常 2）落单要产生新的update sql语句，并且返回int值，根据int值再来减库存，这些都是对于stock表的操作 3）注意操作都是在Service层之间互相调用的，隔离开来Mapper 4）产生新的订单信息，也要计算金额，并将Model转为DO 5）将DO写入数据库 6）但是这里id为主键（string）需要生成交易流水号：订单号16位，前八位为时间信息，年月日（用于归档消除数据库使用），中间6位为自增序列（保证订单号不重复，如果超过6位数字还要再增大），最后2位为分库分表位（00到99，对订单进行用户水平拆分） 为什么加了Transactional标签后反而private不能写入？ 123//分库分表路由信息Integer userId = 1000122;userId % 100 // 100个库的100个表里 这里还有一个问题就是对于sequence表解决序列数字问题的过程中，还有可能造成超出6位，这时就需要对表进行循环写入。还有就是事务处理包含在了一个Transactional当中，失败回滚时候，序列号也需要被处理。这时修改get序列号的方法加入新的Transactional参数就可以完成修改。 构建Controller 获取用户id 检查id后进行商品的订单处理，库存减少 调整Model和Dao的数量问题，使其对等（BeanUtils.copyPropertities） 对库存进行调整，销量增加]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot读取数据库乱码]]></title>
    <url>%2F2019%2F07%2F01%2FSpringBoot%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[读写数据库中文乱码问题这是一个很常见的读写问题，现在需要再次整理一下具体做法。 IDEA的问题 打开setting-&gt;editor-&gt;code Style-&gt;FileEncodings，发现IDE已经为UTF-8的编码，可以排除IDE的问题。 Mysql的连接驱动 目前使用的连接URL为： 1jdbc:mysql://localhost:3306/数据库?useUnicode=true&amp;amp;characterEncoding=utf-8 问号后面挂接的unicode编码的支持，设定为utf-8. 当前很多项目的问题都是这个 数据库设置的问题 在设置数据库的过程中建表过程主动设置为UTF-8也是非常有作用的设置方式 数据库的默认设置这个参考数据库的具体设置，可以在默认设置里修改]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Serverless与Faas的探究]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%85%B3%E4%BA%8EServerless%E4%B8%8EFaas%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[关于Serverless与Faas这里的FAAS是指function as a service，主要实现有开源的OpenFaas（基于docker）与亚马逊的Lambda来实现。而Serverless现有的业界处理方案还是集中在下图类似的情景下：但注意，思维不要局限，这只是业界如何使用的例子，应当对如何进一步拓宽使用范围抱有信心。“将业务函数抽象成一个个 FAAS 函数，将数据库、缓存、加速等服务抽象成 BAAS 服务。上层提供 Restful 或事件触发机制调用，对应到不同的端（PC、移动端）。想要拓展平台能力，只要在端上做开放（组件接入）与 FAAS 服务做开放（后端接入）即可。” 对于现状的一种分析：这里挂一篇笔者的文章，参见笔记《理论 - 知乎：Serverless是进步还是退步》两篇论文的地址Serverless computing：One Step Forward，Two Steps BackCloud Programming Simplified：A Berkeley View on Serverless Computing 说的很清楚，现有的Serverless服务主要的一个优势和两个问题：Faas是“事件驱动”的，因此需要有更好的事件驱动支持优势：解耦，使得服务的部署更加简单以及松耦合. “提供了一种弹性的，自动扩缩容的编程模式，是一大进步。”劣势：1）传统服务为将代码传输到数据端工作，现有服务则是将数据传输到代码端工作，即“Data-shipping”模式，忽视了数据处理的效率2）阻碍了分布式计算的发展，“ Faas 的函数之间不是通过网络进行端到端通信的，那么以计算机网络为基础的分布式计算理论和通信协议，例如数据一致性，leader 选举，分布式事务等的发展会受到阻碍。” 联想的另一端是互联网之父的solid项目，有其他的参考意义在其中同时，RDF（Resource Description Framework）的理解，也有提及：即语义网]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>技术理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP粘包问题成因及其解决办法]]></title>
    <url>%2F2019%2F04%2F13%2FTCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%88%90%E5%9B%A0%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[研究TCP粘包问题近期和同学讨论了一个关于TCP粘包的问题，他在分布式机器学习的数据传输中发现TCP通信出现问题。因此也研究了一下自己之前项目中使用的代码 —— 是通过规定头部字段记录代码长度的方式来实现的。这里总结一下查到的资料。引用博客 问题的成因 socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说，就容易进行区分处理了,所以UDP不会出现粘包问题。 实际上TCP是面向流的传输协议，而UDP是面向消息的传输协议，如何保护消息边界的问题是解决粘包问题的关键。 产生粘包的两种情况 1发送端需要等缓冲区满才发送出去，造成粘包 2接收方不及时接收缓冲区的包，造成多个包接收 具体点：（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结构数据的粘包问题时，分包算法就比较复杂。特别是粘在一起的包有不完整的包的粘包情况，由于一包数据内容被分在了两个连续的接收包中，处理起来难度较大。实际工程应用中应尽量避免出现粘包现象。 解决方案 (1)发送固定长度的消息 (2)把消息的尺寸与消息一块发送 (3)使用特殊标记来区分消息间隔 之前的代码之前的一种限定长度的代码为： 发送：1234567@classmethod def encode_socket_data(cls, data: object) -&gt; bytes: """Our protocol is: first 4 bytes signify msg length.""" def int_to_8bytes(a: int) -&gt; bytes: return binascii.unhexlify(f"&#123;a:0&#123;8&#125;x&#125;") to_send = Utils.serialize(data).encode() return int_to_8bytes(len(to_send)) + to_send 接收：123456789101112try: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect(peer()) s.sendall(Utils.encode_socket_data(message)) logger.info(f'[p2p] succeed to send BlocksSyncReq to &#123;peer&#125;') msg_len = int(binascii.hexlify(s.recv(4) or b'\x00'), 16) data = b'' while msg_len &gt; 0: tdat = s.recv(1024) data += tdat msg_len -= len(tdat) s.close() 规定开头四字节的长度即可在缓冲区中区分TCP数据包。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>技术理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2P网络中内网穿透的方法]]></title>
    <url>%2F2019%2F01%2F22%2FP2P%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[P2P网络中内网穿透的方法今天学长让我查一下这个，研究了一下，各种资料五花八门，自己总结了一下备查。是关于一个局域网和外网之间连接的问题:首先问题的关键在于： 由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。 方案一理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。Python写的比较常用的实现TCP内网穿透的服务器是ShootBack： 方案二另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；但这种方法存在的问题：——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；——这种方法受到不同网络状况和设备的影响很大；——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况； 方案三STUN协议和TURN协议STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。网上开源项目也很多：显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualEnv常用命令]]></title>
    <url>%2F2019%2F01%2F14%2FVirtualEnv%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近python用的多Pycharm的基本配置和记录中Virtualenv的使用都记录在这里。基本配置再有这是virtualenv的所有基础操作基础操作 自己Mac的virtualenv环境在：~/.virtualenv文件夹下面。一些常见的virtual命令：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>技术链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志模板]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[XXXX # 一级标题斜体文字加粗文字粗斜体文字 文本居中的引用测试测试2 hello worldfor(int i=0;i&lt;len;i++){ step++;} 文字内容 (md class_name supported) 文字内容 (md primary supported) 文字内容 (md default supported) 文字内容 (md success supported) 文字内容 (md info supported) 文字内容 (md warning supported) 文字内容 (md danger supported) 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[众包项目]]></title>
    <url>%2F2019%2F01%2F13%2F%E4%BC%97%E5%8C%85%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[边缘群智项目记录2019.1.13打卡，明天下午一点开会，开始搞这个，记录一下流程。众包相关知识快速代码上手 项目入门项目介绍图，是一些学长的资料 第一个研究问题是关于一个局域网和外网之间连接的问题:首先问题的关键在于： 由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。 方案一理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。Python写的比较常用的实现TCP内网穿透的服务器是ShootBack： 方案二另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；但这种方法存在的问题：——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；——这种方法受到不同网络状况和设备的影响很大；——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况； 方案三STUN协议和TURN协议STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。网上开源项目也很多：显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。]]></content>
      <categories>
        <category>区块链</category>
        <category>众包</category>
      </categories>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习和大数据资料整理]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[机器学习相关技术链接贴一些常用的链接就不到Chorme tabs里找了。 机器学习 我的google云盘吴恩达b站视频林轩石机器学习莫烦的TF教程西瓜书答案贝叶斯讲解PRML书目 大数据 CS231n: Convolutional Neural Networks for Visual RecognitionScalable Machine LearningIntroduction to Apache Spark]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>技术链接</tag>
      </tags>
  </entry>
</search>
