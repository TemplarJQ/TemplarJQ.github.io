<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJQ&#39;s Blog</title>
  
  <subtitle>但行好事，莫问前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/TemplarJQ/"/>
  <updated>2019-07-09T15:44:09.406Z</updated>
  <id>https://github.com/TemplarJQ/</id>
  
  <author>
    <name>Jiaqi Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot秒杀商城</title>
    <link href="https://github.com/TemplarJQ/2019/07/02/SpringBoot%E7%A7%92%E6%9D%80%E5%95%86%E5%9F%8E/"/>
    <id>https://github.com/TemplarJQ/2019/07/02/SpringBoot秒杀商城/</id>
    <published>2019-07-02T03:09:55.000Z</published>
    <updated>2019-07-09T15:44:09.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot秒杀商城"><a href="#SpringBoot秒杀商城" class="headerlink" title="SpringBoot秒杀商城"></a>SpringBoot秒杀商城</h1><p>SpringBoot并非什么新的框架，SpringBoot就是Spring + Boot，如同Maven整合了所有的jar包一样，SpringBoot整合了所有框架，并通过main函数启动。</p><h2 id="开发设计"><a href="#开发设计" class="headerlink" title="开发设计"></a>开发设计</h2><h3 id="1-1-项目建立"><a href="#1-1-项目建立" class="headerlink" title="1.1 项目建立"></a>1.1 项目建立</h3><ul><li>maven-archetype-quickstart建立SpringBoot项目</li></ul><br><br><br>- 引入parent依赖与starter依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li><p>加入注解使得SpringBoot开始运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableAutoConfiguration # Spring化</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">        SpringApplication.run(App.class, args); # 将App变成bean的形式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增加rest式外部访问流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line">@RestController # rest访问控制</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @RequestMapping("/") # rest映射</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-文件配置"><a href="#1-2-文件配置" class="headerlink" title="1.2 文件配置"></a>1.2 文件配置</h3><ul><li>加入application.propertites配置文件就可以配置端口等</li><li><p>配置数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在application.properties中加入mybatis.mapper-locations=classpath:mapping/*.xml支持</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot秒杀商城&quot;&gt;&lt;a href=&quot;#SpringBoot秒杀商城&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot秒杀商城&quot;&gt;&lt;/a&gt;SpringBoot秒杀商城&lt;/h1&gt;&lt;p&gt;SpringBoot并非什么新的框架，Spr
      
    
    </summary>
    
      <category term="Java" scheme="https://github.com/TemplarJQ/categories/Java/"/>
    
      <category term="Spring" scheme="https://github.com/TemplarJQ/categories/Java/Spring/"/>
    
    
      <category term="项目笔记" scheme="https://github.com/TemplarJQ/tags/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于Serverless与Faas的探究</title>
    <link href="https://github.com/TemplarJQ/2019/05/11/%E5%85%B3%E4%BA%8EServerless%E4%B8%8EFaas%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://github.com/TemplarJQ/2019/05/11/关于Serverless与Faas的探究/</id>
    <published>2019-05-11T03:47:53.000Z</published>
    <updated>2019-07-02T03:53:47.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Serverless与Faas"><a href="#关于Serverless与Faas" class="headerlink" title="关于Serverless与Faas"></a>关于Serverless与Faas</h1><p>这里的FAAS是指function as a service，主要实现有开源的OpenFaas（基于docker）与亚马逊的Lambda来实现。<br>而Serverless现有的业界处理方案还是集中在下图类似的情景下：<br>但注意，思维不要局限，这只是业界如何使用的例子，应当对如何进一步拓宽使用范围抱有信心。<br>“将业务函数抽象成一个个 FAAS 函数，将数据库、缓存、加速等服务抽象成 BAAS 服务。<br>上层提供 Restful 或事件触发机制调用，对应到不同的端（PC、移动端）。<br>想要拓展平台能力，只要在端上做开放（组件接入）与 FAAS 服务做开放（后端接入）即可。”</p><h2 id="对于现状的一种分析："><a href="#对于现状的一种分析：" class="headerlink" title="对于现状的一种分析："></a>对于现状的一种分析：</h2><p>这里挂一篇笔者的文章，参见笔记《理论 - 知乎：Serverless是进步还是退步》<br>两篇论文的地址<br><a href="https://arxiv.org/abs/1812.03651" target="_blank" rel="noopener">Serverless computing：One Step Forward，Two Steps Back</a><br><br><a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.html" target="_blank" rel="noopener">Cloud Programming Simplified：A Berkeley View on Serverless Computing</a><br></p><p>说的很清楚，现有的Serverless服务主要的一个优势和两个问题：<br>Faas是“事件驱动”的，因此需要有更好的事件驱动支持<br>优势：<br>解耦，使得服务的部署更加简单以及松耦合.</p><blockquote><p>“提供了一种弹性的，自动扩缩容的编程模式，是一大进步。”<br>劣势：<br>1）传统服务为将代码传输到数据端工作，现有服务则是将数据传输到代码端工作，即“Data-shipping”模式，忽视了数据处理的效率<br>2）阻碍了分布式计算的发展，<br>“ Faas 的函数之间不是通过网络进行端到端通信的，那么以计算机网络为基础的分布式计算理论和通信协议，例如数据一致性，leader 选举，分布式事务等的发展会受到阻碍。”</p></blockquote><h2 id="联想的另一端是互联网之父的solid项目，有其他的参考意义在其中"><a href="#联想的另一端是互联网之父的solid项目，有其他的参考意义在其中" class="headerlink" title="联想的另一端是互联网之父的solid项目，有其他的参考意义在其中"></a>联想的另一端是互联网之父的solid项目，有其他的参考意义在其中</h2><p>同时，RDF（Resource Description Framework）的理解，也有提及：即语义网</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于Serverless与Faas&quot;&gt;&lt;a href=&quot;#关于Serverless与Faas&quot; class=&quot;headerlink&quot; title=&quot;关于Serverless与Faas&quot;&gt;&lt;/a&gt;关于Serverless与Faas&lt;/h1&gt;&lt;p&gt;这里的FAAS是指f
      
    
    </summary>
    
      <category term="云计算" scheme="https://github.com/TemplarJQ/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="技术理论" scheme="https://github.com/TemplarJQ/tags/%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>TCP粘包问题成因及其解决办法</title>
    <link href="https://github.com/TemplarJQ/2019/04/13/TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%88%90%E5%9B%A0%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://github.com/TemplarJQ/2019/04/13/TCP粘包问题成因及其解决办法/</id>
    <published>2019-04-13T08:11:42.000Z</published>
    <updated>2019-07-02T04:40:07.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="研究TCP粘包问题"><a href="#研究TCP粘包问题" class="headerlink" title="研究TCP粘包问题"></a>研究TCP粘包问题</h1><p>近期和同学讨论了一个关于TCP粘包的问题，他在分布式机器学习的数据传输中发现TCP通信出现问题。因此也研究了一下自己之前项目中使用的代码 —— 是通过规定头部字段记录代码长度的方式来实现的。<br><br>这里总结一下查到的资料。<br><br><a href="https://blog.csdn.net/zhangxinrun/article/details/6721427" target="_blank" rel="noopener">引用博客</a></p><h2 id="问题的成因"><a href="#问题的成因" class="headerlink" title="问题的成因"></a>问题的成因</h2><blockquote><p>socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。<br><br>这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。<br>对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说，就容易进行区分处理了,所以UDP不会出现粘包问题。</p></blockquote><p>实际上TCP是面向流的传输协议，而UDP是面向消息的传输协议，如何保护消息边界的问题是解决粘包问题的关键。</p><h2 id="产生粘包的两种情况"><a href="#产生粘包的两种情况" class="headerlink" title="产生粘包的两种情况"></a>产生粘包的两种情况</h2><ul><li>1发送端需要等缓冲区满才发送出去，造成粘包</li><li>2接收方不及时接收缓冲区的包，造成多个包接收<blockquote><p>具体点：<br>（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。<br>（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。<br>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。<br>不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。<br>在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结构数据的粘包问题时，分包算法就比较复杂。特别是粘在一起的包有不完整的包的粘包情况，由于一包数据内容被分在了两个连续的接收包中，处理起来难度较大。实际工程应用中应尽量避免出现粘包现象。</p></blockquote></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>(1)发送固定长度的消息</li><li>(2)把消息的尺寸与消息一块发送</li><li>(3)使用特殊标记来区分消息间隔</li></ul><h2 id="之前的代码"><a href="#之前的代码" class="headerlink" title="之前的代码"></a>之前的代码</h2><p>之前的一种限定长度的代码为：<br></p><p>发送：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode_socket_data</span><span class="params">(cls, data: object)</span> -&gt; bytes:</span></span><br><span class="line">        <span class="string">"""Our protocol is: first 4 bytes signify msg length."""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">int_to_8bytes</span><span class="params">(a: int)</span> -&gt; bytes:</span></span><br><span class="line">            <span class="keyword">return</span> binascii.unhexlify(<span class="string">f"<span class="subst">&#123;a:<span class="number">0</span>&#123;<span class="number">8</span>&#125;</span>x&#125;"</span>)</span><br><span class="line">        to_send = Utils.serialize(data).encode()</span><br><span class="line">        <span class="keyword">return</span> int_to_8bytes(len(to_send)) + to_send</span><br></pre></td></tr></table></figure></p><p>接收：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">                s.connect(peer())</span><br><span class="line">                s.sendall(Utils.encode_socket_data(message))</span><br><span class="line">                logger.info(<span class="string">f'[p2p] succeed to send BlocksSyncReq to <span class="subst">&#123;peer&#125;</span>'</span>)</span><br><span class="line">                msg_len = int(binascii.hexlify(s.recv(<span class="number">4</span>) <span class="keyword">or</span> <span class="string">b'\x00'</span>), <span class="number">16</span>)</span><br><span class="line">                data = <span class="string">b''</span></span><br><span class="line">                <span class="keyword">while</span> msg_len &gt; <span class="number">0</span>:</span><br><span class="line">                    tdat = s.recv(<span class="number">1024</span>)</span><br><span class="line">                    data += tdat</span><br><span class="line">                    msg_len -= len(tdat)</span><br><span class="line">            s.close()</span><br></pre></td></tr></table></figure></p><p>规定开头四字节的长度即可在缓冲区中区分TCP数据包。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;研究TCP粘包问题&quot;&gt;&lt;a href=&quot;#研究TCP粘包问题&quot; class=&quot;headerlink&quot; title=&quot;研究TCP粘包问题&quot;&gt;&lt;/a&gt;研究TCP粘包问题&lt;/h1&gt;&lt;p&gt;近期和同学讨论了一个关于TCP粘包的问题，他在分布式机器学习的数据传输中发现TCP通
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://github.com/TemplarJQ/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="技术理论" scheme="https://github.com/TemplarJQ/tags/%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>P2P网络中内网穿透的方法</title>
    <link href="https://github.com/TemplarJQ/2019/01/22/P2P%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/TemplarJQ/2019/01/22/P2P网络中内网穿透的方法/</id>
    <published>2019-01-22T13:11:00.000Z</published>
    <updated>2019-01-22T13:52:21.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="P2P网络中内网穿透的方法"><a href="#P2P网络中内网穿透的方法" class="headerlink" title="P2P网络中内网穿透的方法"></a>P2P网络中内网穿透的方法</h1><p>今天学长让我查一下这个，研究了一下，各种资料五花八门，自己总结了一下备查。<br><br>是关于一个局域网和外网之间连接的问题:<br><br><br><br><br><br>首先问题的关键在于：<br><br><img src="/2019/01/22/P2P网络中内网穿透的方法/resolution1.jpg" title="问题分析"><br></p><p>由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。<br></p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一<br></h2><p>理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。<br>Python写的比较常用的实现TCP内网穿透的服务器是ShootBack：<br><br><img src="/2019/01/22/P2P网络中内网穿透的方法/resolution2.jpg" title="tcp"><br></p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二<br></h2><p>另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。<br><br>它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。<br><br>且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。<br>这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。<br><br>现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；<br><br>但这种方法存在的问题：<br><br>——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；<br><br>——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；<br><br>——这种方法受到不同网络状况和设备的影响很大；<br><br>——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况；<br></p><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三<br></h2><p>STUN协议和TURN协议<br><br>STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。<br><br><img src="/2019/01/22/P2P网络中内网穿透的方法/resolution.jpg" title="stun"><br><br>如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。<br><br>网上开源项目也很多：<br><br>显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。<br><br><img src="/2019/01/22/P2P网络中内网穿透的方法/resolution4.jpg" title="pynat"><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;P2P网络中内网穿透的方法&quot;&gt;&lt;a href=&quot;#P2P网络中内网穿透的方法&quot; class=&quot;headerlink&quot; title=&quot;P2P网络中内网穿透的方法&quot;&gt;&lt;/a&gt;P2P网络中内网穿透的方法&lt;/h1&gt;&lt;p&gt;今天学长让我查一下这个，研究了一下，各种资料五花八门
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://github.com/TemplarJQ/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="技术总结" scheme="https://github.com/TemplarJQ/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>VirtualEnv常用命令</title>
    <link href="https://github.com/TemplarJQ/2019/01/14/VirtualEnv%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/TemplarJQ/2019/01/14/VirtualEnv常用命令/</id>
    <published>2019-01-14T08:40:53.000Z</published>
    <updated>2019-01-14T10:56:27.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近python用的多"><a href="#最近python用的多" class="headerlink" title="最近python用的多"></a>最近python用的多</h1><p>Pycharm的基本配置和记录中Virtualenv的使用都记录在这里。<br><br><a href="https://www.cnblogs.com/geeklove01/p/8030214.html" target="_blank" rel="noopener">基本配置</a><br><br>再有这是virtualenv的所有基础操作<br><br><a href="https://blog.csdn.net/makodoo/article/details/79228692" target="_blank" rel="noopener">基础操作</a><br></p><p></p><p><br>自己Mac的virtualenv环境在：~/.virtualenv文件夹下面。<br><br>一些常见的virtual命令：<br><br><img src="/2019/01/14/VirtualEnv常用命令/virtualenv命令.jpg" title="virtualenv常见命令"><br> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最近python用的多&quot;&gt;&lt;a href=&quot;#最近python用的多&quot; class=&quot;headerlink&quot; title=&quot;最近python用的多&quot;&gt;&lt;/a&gt;最近python用的多&lt;/h1&gt;&lt;p&gt;Pycharm的基本配置和记录中Virtualenv的使用都记录在这
      
    
    </summary>
    
      <category term="Python" scheme="https://github.com/TemplarJQ/categories/Python/"/>
    
    
      <category term="技术链接" scheme="https://github.com/TemplarJQ/tags/%E6%8A%80%E6%9C%AF%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>日志模板</title>
    <link href="https://github.com/TemplarJQ/2019/01/14/%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF/"/>
    <id>https://github.com/TemplarJQ/2019/01/14/日志模板/</id>
    <published>2019-01-14T08:11:13.000Z</published>
    <updated>2019-01-14T10:51:09.820Z</updated>
    
    <content type="html"><![CDATA[<!-- 引言 --><blockquote><footer><strong>XX</strong><cite>XX</cite></footer></blockquote><hr><!-- 引入图片 --><img src="/2019/01/14/日志模板/jfla.jpg" title="测试"><br><br><br># 一级标题<br><br><em>斜体文字</em><br><strong>加粗文字</strong><br><strong><em>粗斜体文字</em></strong><br><br><blockquote class="blockquote-center"><p> 文本居中的引用<br>测试<br>测试2  </p></blockquote><!-- 分割线 --><hr><hr><!-- 行内代码 --><p><code>hello world</code><br><code>for(int i=0;i&lt;len;i++){</code><br>    <code>step++;</code><br><code>}</code></p><!-- 灰色底板 --><div class="note class_name">            <p>文字内容 (md class_name supported) </p>          </div><!-- 紫色 --><div class="note primary">            <p>文字内容 (md primary supported) </p>          </div><!-- 深灰 --><div class="note default">            <p>文字内容 (md default supported) </p>          </div><!-- 绿色 --><div class="note success">            <p>文字内容 (md success supported) </p>          </div><!-- 蓝色 --><div class="note info">            <p>文字内容 (md info supported) </p>          </div><!-- 黄色 --><div class="note warning">            <p>文字内容 (md warning supported) </p>          </div><!-- 红色 --><div class="note danger">            <p>文字内容 (md danger supported) </p>          </div><!-- 待办事项 --><ul><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 引言 --&gt;
&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;XX&lt;/strong&gt;&lt;cite&gt;XX&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;hr&gt;

&lt;!-- 引入图片 --&gt;
&lt;img src=&quot;/2019/01/14/日志模板/jfla
      
    
    </summary>
    
      <category term="日志" scheme="https://github.com/TemplarJQ/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="https://github.com/TemplarJQ/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="心情" scheme="https://github.com/TemplarJQ/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>众包项目</title>
    <link href="https://github.com/TemplarJQ/2019/01/13/%E4%BC%97%E5%8C%85%E9%A1%B9%E7%9B%AE/"/>
    <id>https://github.com/TemplarJQ/2019/01/13/众包项目/</id>
    <published>2019-01-13T13:51:55.000Z</published>
    <updated>2019-01-22T13:52:24.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="边缘群智项目记录"><a href="#边缘群智项目记录" class="headerlink" title="边缘群智项目记录"></a>边缘群智项目记录</h1><p>2019.1.13打卡，明天下午一点开会，开始搞这个，记录一下流程。<hr><br><a href="https://github.com/EdgeIntelligenceChain/Materials2Study">众包相关知识</a><br><br><a href="https://github.com/EdgeIntelligenceChain/EdgenceChain/issues/6">快速代码上手</a><br></p><h2 id="项目入门"><a href="#项目入门" class="headerlink" title="项目入门"></a>项目入门</h2><p>项目介绍图，是一些学长的资料<br><br><img src="/2019/01/13/众包项目/introToCrowdsourcing.jpg" title="众包简介"><br><br><!-- ![众包简介](众包项目/introToCrowdsourcing.jpg) --></p><h2 id="第一个研究问题"><a href="#第一个研究问题" class="headerlink" title="第一个研究问题"></a>第一个研究问题</h2><p>是关于一个局域网和外网之间连接的问题:<br><br><img src="/2019/01/13/众包项目/question.jpg" title="问题简介"><br><br><br><br>首先问题的关键在于：<br><br><img src="/2019/01/13/众包项目/resolution1.jpg" title="问题分析"><br></p><p>由于动态NAPT的映射关系是LAN侧数据包来触发的，如果WAN侧有主动进来的数据包，因为查询不到映射关系的存在，就会被丢弃掉。所以这时需要内网穿透。<br></p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一<br></h3><p>理念是构建一个公网中的服务端，两个内网中的客户端都相当于向该服务器注册，然后发送三次握手，可互相发现，实现NAT穿透。<br>Python写的比较常用的实现TCP内网穿透的服务器是ShootBack：<br><br><img src="/2019/01/13/众包项目/resolution2.jpg" title="tcp"><br></p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二<br></h3><p>另一个比较简单的方式是：端口映射(Port Mapping或者叫Port Forwarding)，也是最基本的一种方式。<br><br>它将NAPT网关WAN侧的指定端口映射到内网指定地址的指定端口上。 这样当网关收到一个从外网过来的封包，就会转发到上述指定的内网地址和端口，对于封包的发起者来说，就像是直接访问这个内网主机一样。<br><br>且当内网的地址和端口都希望是动态的时候就需要“动态端口映射”，也就是UPnP里面的IGD（Internet Gateway Device）控制协议。<br>这种方式下的情形就是： 把节点连接在某个UPnP分配的节点上，然后外部直接来连接这个端口。<br><br>现在了解到的python下分离并加强这种分配端口方法的的包就是miniUpnp，还有待于了解；<br><br>但这种方法存在的问题：<br><br>——使用UPNP穿透NAT的方法会使得机器不安全，极其容易卡死路由器和其他问题；<br><br>——最初是为各种设备，后来发展为一般都是为电驴等软件配置某一个外部端口的时候开启，而自己写的某种程序能否做到端口映射问题很大，且开源多基于C；<br><br>——这种方法受到不同网络状况和设备的影响很大；<br><br>——多用于家庭内的树莓派或者设备连接外部公司里电脑这种情况；<br></p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三<br></h3><p>STUN协议和TURN协议<br><br>STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。<br><br><img src="/2019/01/13/众包项目/resolution.jpg" title="stun"><br><br>如图，在N层NAT后面的client向Server询问自己的外网IP和端口号，然后直接用于连接，这样就可以直接使用外部端口和IP，避免使用私网IP和端口无法被访问的问题。<br><br>网上开源项目也很多：<br><br>显然pystun支持的是python2.7之前的版本，现在版本需要的是pynat。<br><br><img src="/2019/01/13/众包项目/resolution4.jpg" title="pynat"><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;边缘群智项目记录&quot;&gt;&lt;a href=&quot;#边缘群智项目记录&quot; class=&quot;headerlink&quot; title=&quot;边缘群智项目记录&quot;&gt;&lt;/a&gt;边缘群智项目记录&lt;/h1&gt;&lt;p&gt;2019.1.13打卡，明天下午一点开会，开始搞这个，记录一下流程。&lt;hr&gt;&lt;br&gt;&lt;a h
      
    
    </summary>
    
      <category term="区块链" scheme="https://github.com/TemplarJQ/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="众包" scheme="https://github.com/TemplarJQ/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BC%97%E5%8C%85/"/>
    
    
      <category term="项目笔记" scheme="https://github.com/TemplarJQ/tags/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习和大数据资料整理</title>
    <link href="https://github.com/TemplarJQ/2019/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%93%BE%E6%8E%A5/"/>
    <id>https://github.com/TemplarJQ/2019/01/13/机器学习和大数据链接/</id>
    <published>2019-01-13T13:06:16.000Z</published>
    <updated>2019-01-14T09:45:06.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习相关技术链接"><a href="#机器学习相关技术链接" class="headerlink" title="机器学习相关技术链接"></a>机器学习相关技术链接</h1><p>贴一些常用的链接就不到Chorme tabs里找了。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><div class="note success">            <p><a href="https://drive.google.com/drive/my-drive" target="_blank" rel="noopener">我的google云盘</a><br><br><a href="https://www.bilibili.com/video/av9912938/?p=1" target="_blank" rel="noopener">吴恩达b站视频</a><br><br><a href="https://redstonewill.com/category/ai-notes/lin-ml-foundations/" target="_blank" rel="noopener">林轩石机器学习</a><br><br><a href="https://www.bilibili.com/video/av16001891/?p=28" target="_blank" rel="noopener">莫烦的TF教程</a><br><br><a href="https://blog.csdn.net/icefire_tyh/article/details/52064910" target="_blank" rel="noopener">西瓜书答案</a><br><br><a href="http://www.xuyankun.cn/2017/05/13/bayes/" target="_blank" rel="noopener">贝叶斯讲解</a><br><br><a href="https://github.com/ctgk/PRML">PRML书目</a><br></p>          </div><!-- []()<br> --><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><div class="note success">            <p><a href="http://cs231n.github.io/" target="_blank" rel="noopener">CS231n: Convolutional Neural Networks for Visual Recognition</a><br><br><a href="https://courses.edx.org/courses/BerkeleyX/CS190.1x/1T2015/course/" target="_blank" rel="noopener">Scalable Machine Learning</a><br><br><a href="https://courses.edx.org/courses/course-v1:BerkeleyX+CS105x+1T2016/course/" target="_blank" rel="noopener">Introduction to Apache Spark</a><br></p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习相关技术链接&quot;&gt;&lt;a href=&quot;#机器学习相关技术链接&quot; class=&quot;headerlink&quot; title=&quot;机器学习相关技术链接&quot;&gt;&lt;/a&gt;机器学习相关技术链接&lt;/h1&gt;&lt;p&gt;贴一些常用的链接就不到Chorme tabs里找了。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="机器学习" scheme="https://github.com/TemplarJQ/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="技术链接" scheme="https://github.com/TemplarJQ/tags/%E6%8A%80%E6%9C%AF%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
</feed>
